var pointCheck = {
    "setingTimer": 0,
    "settingData": [],
    "settingIndex": 0,
    "settingCheck": function () {
        let itemPromise = Promise.resolve();
        let data = gaoya_list[curIndex]
        if (!data || !data.hasOwnProperty("setting") || data.setting.trim().length <= 0) return;
        this.settingData = data.setting.split('=>');
        let controlList = this.settingData[this.settingIndex].split("||");
        for (var i = 0; i < controlList.length; i++) {
            let setting = controlList[i].split("&");
            let getData = setting[0].split(";");
            let get_value = ""
            getData[0].split(",").forEach((item) => {
                itemPromise = itemPromise.then(() => {
                    return getIO(Number(item)).then((value) => {
                        get_value += value + ',';
                    });
                })
            })
            itemPromise.then(() => {
                console.log("get_value:" + get_value);
                console.log("point_check_golden:" + getData[1]);
                if (get_value == (getData[1] + ",")) {
                    //检测成功，
                    this.doSetting(setting[1]);
                } else {
                    this.startSettingTimer();
                }
            })
        }
    },
    "doSetting": function (data) {
        let itemPromise = Promise.resolve();
        data.split(";").forEach((item) => {
            item = item.split("-");
            itemPromise = itemPromise.then(() => {
                return setIO(Number(item[0]), Number(item[1]));
            })
        })
        itemPromise.then(() => {
            if (this.settingIndex < (this.settingData.length - 1)) {
                this.settingIndex++
                this.startSettingTimer();
            } else {
                this.stopSettingCheck();
            }
        })
    },
    "startSettingTimer": function (bReset = false) {
        if (bReset) {
            this.settingIndex = 0;
        } else {
            if (this.setingTimer == -1) {
                return;
            }
        }
        clearTimeout(this.setingTimer);
        this.setingTimer = setTimeout(() => {
            pointCheck.settingCheck();
        }, timerInterval);
    },
    "stopSettingCheck": function () {
        clearTimeout(this.setingTimer);
        this.setingTimer = -1;
    },
    "pointTimer": 0,
    "pointValue": [],
    "rangePointValue": [],
    "rankFlag": 0,
    "isRplaced": [],
    "startPointTimer": function (bReset = false) {
        if (bReset) {
            this.pointValue = [];
            this.rangePointValue = [];
            this.rankFlag = 0
            this.isRplaced = [false, false, false, false]
            this.multistepPointList = []
        } else {
            if (this.pointTimer == -1) {
                return;
            }
        }
        clearTimeout(this.pointTimer);
        this.pointTimer = setTimeout(() => {
            pointCheck.checkpoint();
        }, timerInterval);
    },
    "stopPointCheck": function () {
        clearTimeout(this.pointTimer);
        this.pointTimer = -1;
    },
    "initValue": [],
    "doPoint": function () {
        let data = gaoya_list[curIndex]
        if (!data || !data.hasOwnProperty("point") || data.point.trim().length <= 0) return;
        let point = data.point.split(';')[1]
        let itemPromise = Promise.resolve();
        point.split(',').forEach((item, index) => {
            itemPromise = itemPromise.then(() => {
                return getIO(Number(item)).then((value) => {
                    if (index < this.pointValue.length) {
                        this.pointValue[index] = (this.pointValue[index] | value)
                    } else {
                        if (data.point.split(';')[0] == 'IT') {
                            if (this.initValue.length < point.split(',').length) {
                                this.initValue.push(value)
                            }
                        } else {
                            this.pointValue.push(value)
                        }
                    }
                });
            })
        })
        itemPromise.then(() => {
            //check 结果，是否要保存
            if (data.point.split(';')[0] == 'IT' && this.initValue.length >= point.split(',').length) {
                clearTimeout(this.pointTimer);
            } else {
                this.startPointTimer();
            }
        })
    },
    "rangePoint": function () {
        let data = gaoya_list[curIndex]
        if (!data || !data.hasOwnProperty("point") || data.point.trim().length <= 0) return;
        let point = data.point.split(';')[1]
        let itemPromise = Promise.resolve();
        point.split(',').forEach((item, index) => {
            itemPromise = itemPromise.then(() => {
                return getIO(Number(item)).then((value) => {
                    const getValue = item + "" + value; //36 0 0
                    if (index < this.rangePointValue.length) {
                        //2.第一次
                        if (this.rangePointValue[index] !== getValue) {
                            if (this.isRplaced[index] === false) {
                                this.pointValue[index] = getValue + this.rankFlag
                                this.rankFlag++
                                this.isRplaced[index] = true
                                this.rangePointValue[index] = getValue
                            } else {
                                this.pointValue[point.split(",").length + (index == 0 ? index : index - 1)] = getValue + this.rankFlag
                                return; //todo
                            }
                        }
                    } else {
                        //1.push出一个初始的数组rangePointValue
                        this.rangePointValue.push(getValue) //2020 361 371 381
                        this.pointValue.push(getValue)
                    }
                });
            })
        })
        itemPromise.then(() => {
            //check 结果，是否要保存
            this.startPointTimer();
        })
    },
    "multistepPointList": [],
    "multistepPoint": function () {//1.初步想采用假点的方式作为判分逻辑
        let data = gaoya_list[curIndex]
        if (!data || !data.hasOwnProperty("point") || data.point.trim().length <= 0) return;
        let point = data.point.split(';')[1]
        let itemPromise = Promise.resolve();
        const split = point.split(',');
        let thisRoundValue = []
        itemPromise = itemPromise.then(() => {
                return split.forEach((item, index) => {
                    getIO(Number(item)).then((value) => {
                        //1.first,

                        if (value === 1) {
                            thisRoundValue.push(item)
                            if (thisRoundValue.length == 2) {

                                if (this.multistepPointList.length < split.length) {
                                    const items = thisRoundValue[0] > thisRoundValue[1] ? thisRoundValue[1] + "" + thisRoundValue[0] : thisRoundValue[0] + "" + thisRoundValue[1];
                                    if (!this.multistepPointList.includes(items)) {
                                        this.multistepPointList.push(items)
                                    }
                                }
                            }
                            // split.splice(index, 1).forEach((i, indexI) => {
                            //     getIO(Number(i)).then((value) => {
                            //         if (value == 1) {
                            //             this.multistepPointList.push(index + "" + i)
                            //         }
                            //     })
                            // })
                        }

                    });
                })
            }
        )
        itemPromise.then(() => {
            //check 结果，是否要保存
            this.startPointTimer();
        })
    },
    "checkpoint":

        function () {
            let data = gaoya_list[curIndex]
            if (!data || !data.hasOwnProperty("point") || data.point.trim().length <= 0) return;
            let point = data.point.split(';')
            if (point[0] == "O" || point[0] == "IT") {
                this.doPoint();
            }
            if (point[0] == "RO") {  //R带排序的；不可重复操作，只能操作一次对的，再操作对的值就会拼接在后面[36,0,37,0,38,0]=>[3610,3712,3813]
                this.rangePoint();
            }
            if (point[0] == "MO") { //多步骤判分
                this.multistepPoint();
            }
        }

    ,
    "getPointValue":
        function () {
            let data = gaoya_list[curIndex]
            let point = data.point.split(';')
            let itemPromise = Promise.resolve();
            if (point[0] != "O" && point[0] != "RO" && point[0] != "MO") {
                this.pointValue = [];
                let data = gaoya_list[curIndex];
                if (!data || !data.hasOwnProperty("point") || data.point.trim().length <= 0) return Promise.resolve(this.pointValue);
                let point = data.point.split(';')[1]
                point.split(',').forEach((item) => {
                    itemPromise = itemPromise.then(() => {
                        return getIO(Number(item)).then((value) => {
                            if (index < this.pointValue.length) {
                                this.pointValue[index] = (this.pointValue[index] | value)
                            } else {
                                this.pointValue.push(value)
                            }
                        });
                    })
                })
                itemPromise = itemPromise.then(() => {
                    if (data.point.split(';')[0] == 'IT') {
                        debugger
                        let isEqual = true;
                        if (this.pointValue.length !== this.initValue.length) {
                            console.log("两个数组不相等");
                            isEqual = false;
                        } else {
                            for (let i = 0; i < this.pointValue.length; i++) {
                                if (this.pointValue[i] !== this.initValue[i]) {
                                    isEqual = false;
                                    break;
                                }
                            }
                        }
                        return Promise.resolve(this.pointValue = isEqual ? [0, 0, 0] : [1, 1, 1]);
                    }
                    return Promise.resolve(this.pointValue);
                })
            } else {
                if (point[0] === "RO") {
                    let str = this.pointValue;
                    let sortedArr = str.slice(1).sort((a, b) => a.slice(-1) - b.slice(-1));
                    this.pointValue = [str[0], ...sortedArr];
                }
                if (point[0] === "MO") {
                    let data = gaoya_list[curIndex]
                    let point = data.point.split(';')[1]
                    const split = point.split(',');
                    for (let i = 0; i < split.length; i++) {
                        for (let j = i + 1; j < split.length; j++) {
                            if (this.multistepPointList.includes(split[i] + "" + split[j])) {
                                this.pointValue.push(1)
                            }
                        }
                    }
                    if (this.pointValue.length != split.length) {
                        this.pointValue = [0, 0, 0]
                    }
                }
                itemPromise = itemPromise.then(() => {
                    return Promise.resolve(this.pointValue);
                })
            }
            return itemPromise;
        }
}